# Everything is a complex double
# "j" is reserved for the imaginary unit
x = 10**2
y = 3.22+j4.02
# Constants like pi, euler
z = x + y + pi + euler

# angles are special Angle objects
w = polar(440, rad(2*pi))
w = polar(440, deg(360))

# Get real/imaginary parts
re(w)
im(w)

# Get angle/magnitude
angleOf(w)
mag(w)

# arrays
v = [1, 2, 3]
A = [[1, 2],
     [3, 4],
     [5, 6]]

# 0 indexing by row, col
element = A[0][2]

# Matrix/vector multiplication
result = A@v

# OPTION 1: like old javascript, php
# Functions
fun add(x, y) = x + y # implicit return for single line functions
fun multiply(x, y) = {
  product = x*y
  return product
}
fun fact(n) = {
  if n == 0 { return 1 }
  return n * fact(n - 1)
}

# Anonymous functions
foo = fun (x, y) {x + y}

# OPTION 2: like ES6
#Functions
add = (x, y) => {x + y}

# OPTION 3: like python lambda
# RHS of ':' takes expr or block
add = lambda x, y : x + y
xor = lambda a, b : {
      a and not b or not a and b
    }

# Scoping rules
# - variables are scoped to blocks
# - if variable has never been declared in current block, will incrementally
    search outward
# - assignment expressions always bind/reassign the variable in the current block
